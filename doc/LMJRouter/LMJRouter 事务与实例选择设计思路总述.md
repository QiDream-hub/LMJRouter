# LMJRouter 事务与实例选择设计思路总述

## 一、核心设计哲学

### 1. **显式优于隐式**
- 所有操作必须明确目标实例
- 不提供自动、隐式或“智能”路由
- 开发者必须清楚知道数据在哪个物理实例

### 2. **控制权完全上交**
- 路由层只做最简单的请求转发
- 复杂决策（如实例选择、错误恢复）完全由上层负责
- 符合 LMJCore “内核极简”的设计传统

### 3. **原子性边界清晰**
- **一个写事务只能操作一个实例**
- 跨实例操作无原子性保证
- 实例边界即事务边界

## 二、事务模型设计

### 写事务：实例绑定
```
写事务开始 → 必须提供目标实例的环境句柄
           ↓
    所有操作 → 必须属于该实例（否则报错）
           ↓
    提交/中止 → 仅影响该实例
```

### 只读事务：透明路由
```
只读事务开始 → 不绑定实例
           ↓
    查询任意指针 → 路由层自动定位实例
           ↓
    提交 → 仅释放资源
```

### 跨实例操作模式
```
操作实例A和B：
1. 事务A（绑定实例A）→ 提交（原子生效）
2. 事务B（绑定实例B）→ 提交（原子生效）
3. 如果B失败：上层自行补偿A的操作
```

## 三、实例选择机制

### 核心原则：**只提供数据，不代替决策**

### 工作流程
```
用户需要创建实体：
1. 主动查询实例状态（可选缓存）
2. 运行自己的选择算法
3. 明确指定目标实例
```

### 不提供的功能
- ❌ 自动实例选择
- ❌ 智能负载均衡
- ❌ 回调式决策
- ❌ 隐式优化

## 四、明确的职责划分

### 路由层责任（极少）
- 根据指针中的实例ID转发请求
- 提供实例状态查询
- 保证单实例内的正确路由

### 上层应用责任（全部）
- 决定数据分布在哪个实例
- 实现实例选择算法
- 处理跨实例操作的一致性
- 实现错误恢复和补偿逻辑

## 五、设计价值

### 1. **可预测性**
- 没有隐藏的优化或魔法
- 所有行为由用户代码明确控制

### 2. **可理解性**
- 架构简单清晰
- 问题容易定位和调试

### 3. **可演进性**
- 用户可以随时改变策略
- 无需修改路由层即可适应新需求

### 4. **嵌入式本质**
- 每个实例是独立的嵌入式数据库
- 路由层只是简单的本地消息路由器

## 六、关键结论

**LMJRouter 不是分布式数据库中间件，而是多个独立 LMJCore 实例的本地连接器。**

它提供：
- 逻辑统一的只读视图
- 物理实例的透明发现
- 明确的能力边界告知

它不提供：
- 跨实例原子性
- 自动负载均衡
- 智能路由决策
- 分布式事务协调

这个设计确保系统保持 **简单、可控、可预测**，完全继承 LMJCore 的极简哲学。